# 파이썬 문법

## 리스트 컴프리헨션

기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문으로, 파이썬 2.0부터 지원되었으며, 하스켈 같은 함수형 언어에서 기능을 차용해온 파이썬의 대표적인 특징이기도 하다.

다음은 홀수인 경우 2를 곱해 출력하라는 리스트 컴프리헨션이다.

```bash
>> [n * 2 for n in range(1, 10 + 1) if n % 2 == 1]
[2, 6, 10, 14, 18]
```

만약 리스트 컴프리헨션을 사용하지 않는다면 다음과 같이 길게 풀어서 작성해야 한다.

```bash
>> a = []
>> for n in range(1, 10 + 1):
	if n % 2 == 1:
	a.append(n * 2)
>> a
[2, 6, 10, 14, 18]
```

풀어서 작성한 코드는 리스트 컴프리헨션에 비해 훨씬 더 길어졌고 a라는 별도의 리스트 변수 또한 필요해졌다.

리스트 컴프리헨션과 비교했을 때 라인 수가 많이 증가했다.

물론 리스트 컴프리헨션이라고 반드시 리스트만 가능한 것은 아니다.

버전 2.7 이후에는 다음과 같이 리스트 외에도 딕셔너리 등이 가능하도록 추가됐다.

```python
a = {}
for key, value in original.items():
    a[key] = value
```

이와 같은 정의 코드는 다음과 같이 처리할 수 있다.

```python
a = {key: value for key, value in original.items()}
```

이처럼 한 줄로 간결하게 작성할 수 있는 리스트 컴프리헨션은 가독성이 좋은 편이지만 이 또한 무리하게 복잡하게 작성할 경우 가독성을 떨어뜨릴 수 있으므로 적절히 사용하는 게 중요하다.

대체로 표현식은 2개를 넘지 않아야 한다.

## 제너레이터

제너레이터는 2001년 파이썬 2.2가 출시될 때 추가된 오래된 기능 중 하나로, 루프의 반복 동작을 제어할 수 있는 루틴 형태를 말한다.

예를 들어 임의의 조건으로 숫자 1억 개를 만들어내 계산하는 프로그램을 작성한다고 가정해보자.

이 경우 제너레이터가 없다면 메모리 어딘가에 만들어낸 숫자 1억 개를 보관하고 있어야 한다.

그러나 제너레이터를 이용하면, 단순히 제너레이터만 생성해두고 필요할 때 언제든 숫자를 만들어낼 수 있다.

만약에 1억 개 중 100개 정도만 쓰인다면 차이는 더욱 클 것이다.

이때 `yield` 구문을 사용하면 제너레이터를 리턴할 수 있다.

기존의 함수는 `return` 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료한다.

그러나 `yield`는 제너레이터가 여기까지 실행 중이던 값을 내보낸다는 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행된다.

물론 다음 코드의 경우처럼 `while True` 구문은 종료 조건이 없으므로 계속해서 값을 내보낼 수 있다.

```python
def get_natural_number():
    n = 0
    while True:
            n += 1
            yield n
```

이 경우 함수의 리턴 값은 제너레이터가 된다.

만약 다음 값을 생성하려면 `next()`로 추출하면 된다.

예를 들어 100개의 값을 생성하고 싶다면 다음과 같이 100번 동안 `next()`를 수행하면 된다.

```shell
>> g = get_natural_number()
>> for _ in range(0, 100):
        print(next(g))
1
2
3
...
100
```

아울러 제너레이터는 다음과 같이 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능하다.

```python
>> def generator():
        yield 1
        yield 'string'
        yield True
```

## range

제너레이터의 방식을 활용하는 대표적인 함수로 `range()`가 있다.

주로 `for`문에서 쓰이는 `range()` 함수의 쓰임은 다음과 같다.

```shell
>> list(range(5))
[0, 1, 2, 3, 4]
>> range(5)
range(0, 5)
>> type(range(5))
<class 'range'>
>> for i in range(5):
        print(i, end=' ')
0 1 2 3 4
```

이 코드에서 `range()`는 `range` 클래스를 리턴하며, `for`문에서 사용할 경우 내부적응로는 제너레이터의 next()를 호출하듯 매번 다음 숫자를 생성해내게 된다.

참고로 파이썬 2.x 버전까지는 `range()` 함수가 지금과 같은 형태가 아니었다.

숫자를 미리 생성해서 리스트로 리턴하는 방식이었고 제너레이터를 리턴하는 방식은 `xrange()`라고 따로 존재했다.

그러다가 버전 3 이후, `range()` 함수가 제너레이터 역할을 하는 `range` 클래스를 리턴하는 형태로 변경됐고 `xrange()` 함수는 사라졌다.

만약 생성할 숫자가 100만개쯤 된다면 어떻게 될까?

메모리에서 적지 않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것이다.

그러나 제너레이터를 리턴하듯 `range` 클래스만 리턴하면 그렇지 않다.

생성 조건만 정해두고 나중에 필요할 때 생성해서 꺼내 쓸 수 있다.

다음은 숫자 100만 개를 생성하는 2가지 방법이다.

```shell
>> a = [n for n in range(1000000)]
>> b = range(1000000)
```

실제로 다음과 같이 `len()`으로 길이 비교를 해보면 둘 다 동일한 100만 개가 출력되며, 비교 연산자에서도 `True`를 리턴한다.

```shell
>> len(a)
1000000
>> len(b)
1000000
>> len(a) == len(b)
True
```

그러나 a에는 이미 생성된 값이 담겨 있고, b는 생성해야 한다는 조건만 존재한다.

```shell
>> b
range(0, 1000000)
>> type(b)
<class 'range'>
```

이제 둘 사이의 메모리 점유율을 비교해보면 `range` 클래스를 리턴하는 방식의 장점이 쉽게 와닿을 것이다.

```shell
>> sys.getsizeof(a)
8697464
>> sys.getsizeof(b)
48
```

똑같이 숫자 100만 개를 갖고 있으나 `range` 클래스를 이용하는 b 변수의 메모리 점유율이 훨씬 더 작다.

100만 개가 아니라 1억 개라도 b 변수의 메모리 점유율은 동일하다.

생성 조건만 보관하고 있기 때문이다.

게다가 미리 생성하지 않은 값은 인덱스에 접근이 안될 거라 생각할 수 있으나, 인덱스로 접근 시에는 바로 생성하도록 구현되어 있기 때문에 다음과 같이 리스트와 거의 동일한 느낌으로 불편 없이 사용할 수 있다.

## enumerate

순서가 있는 자료형을 인덱스를 포함한 enumerate 객체로 리턴한다.

## // 나눗셈 연산자

정수형을 나눗셈할 때 동일한 정수형을 결과로 리턴하면서 내림 연산자의 역할을 한다.

다시 말해 몫을 구하는 연산자다.

몫과 나머지를 동시에 구하려면 `divmod()` 함수를 사용하면 된다.

## print

```shell
>> print("A1", "B2")
A1 B2
>> print("A1", "B2", sep=",")
A1,B2
>> print("aa", end=" ")
print("bb")
aa bb
```

## pass

## locals

`locals()`는 로컬 심볼 테이블 딕셔너리를 가져오는 메소드로 업데이트 또한 가능하다.

여기서는 딕셔너리를 가져오는 부분에 집중해 살펴봊면, 우선 로컬에 선언된 모든 변수를 조회할 수 있는 강력한 명령이므로 디버깅에 많은 도움이 된다.

`pprint`로 출력하게 되면 보기 좋게 줄바꿈 처리를 해주기 때문에 가독성이 높다.
